# 后台开发面试问题总结
[简书|后台开发面试问题总结](https://www.jianshu.com/p/7bab37d411a8)

1. 析构函数原理以及步骤  
    - 析构函数的作用：当对象的生命周期结束时，会自动调用析构函数，以清理一些资源，比如释放内存、关闭文件、关闭数据库连接等。
    - 析构函数的顺序：析构函数析构顺序和构造函数构造对象顺序相反，是从派生类开始往基类进去一步步析构。所以，如果在有继承的类对象里，且有虚函数的存在，那么析构函数一定是虚函数。因为如果析构函数不是虚函数，那么基类指针对象调用的析构函数就仅仅是基类析构。而不释放派生类部分的对象，会导致内存泄漏。（因为析构时，编译器已经知道了对象的构造，已经拥有VPTR，所以可以是虚函数。但构造函数明显还不知道，所以不能是虚函数。）  

2. 类对象的内存存储形式  
    - 如果是一个普通的类的对象，那么会在堆（用new）或者栈（函数内创建局部变量）中直接分配类里声明的成员变量空间，并对这些成员变量调用构造进行初始化存储。
    - 成员函数则会有一个ptr指向类代码区，并不会占用堆栈空间。每次a->func()调用成员函数的时候，会根据指针直接去代码区找到函数运行。
    - 如果类拥有虚函数，则对象内存一开始会有一个VPTR，指向该类的虚函数表，实现虚函数的晚捆绑。  
    - 如果该类有多重继承，且上层具有虚继承，则该对象除上面所说以外，还有一个vbptr，该指针指向虚基类表，表中存储了基类成员和自己的偏移量。这种多重继承，只拷贝一份基类成员，但是多一个指针的开销。

3. 进程内存空间分布
    - ![进程内存分布图](http://ww1.sinaimg.cn/large/005xfSxkly1g1031fgnspg30bo09xaac.gif)
    - 内存从上到下分为：内核区、栈（向下增长）、动态库、堆（向上增长）、静态变量以及常量区还有最下面的代码区。
4. 虚函数的作用
    - C++多态通过虚函数实现。可以实现不同对象自动调用不同的接口。在基类中使用virtual关键字使得该函数成为虚函数，且定义和派生类都不需要再次声明virtual关键字。在派生类中重定义虚函数被称为重写（overriding）。
    - 虚函数实现机制是晚捆绑，一般的函数在编译期间就被编译器转化成了CALL 某个地址，然后进入该函数，直到RETURN出来。但是虚函数在编译期间并不知道具体调用什么。只有在运行时，根据该对象的VPTR指向的虚函数表（VTABLE）中寻找真正调用的函数。
    - 所以，虚函数的实现方式是在构造该对象时，在最前面加上一个VPTR，该指针指向一张虚函数表，这张虚函数表里存了该类真正被调用的函数地址。（VPTR是针对对象的，每个对象都有一个，VTABLE是针对类的，不占用对象存储空间。）
    - 当出现多重继承的时候，子类拥有多个VPTR指向多张VTABLE，子类的虚函数跟在第一张VTABLE后面。  
    - 纯虚函数：纯虚函数需要在虚函数声明后面加一个“=0”，拥有纯虚函数的类不允许用户创建对象。纯虚函数不用定义（纯虚析构除外，纯虚析构必须定义函数体，否则析构不做任何操作有违析构本意）。纯虚函数可以让基类成为一个纯粹的接口模板，让子类继承后去实现这个纯虚函数。且限制了该模板基类的对象创建。      
5.  如何定位内存泄漏
    ```C++  
    //在主函数文件中加入如下代码

    #include <stdlib.h>  
    #include <crtdbg.h>  

    /*
    #ifdef _DEBUG  
    #define new new(_NORMAL_BLOCK, __FILE__, __LINE__)  
    #endif  
    */

    void EnableMemLeakCheck()
    {
    	int tmpFlag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
    	tmpFlag |= _CRTDBG_LEAK_CHECK_DF;  
        _CrtSetDbgFlag(tmpFlag);      
    }

    using namespace std;
    int main()
    {
    	EnableMemLeakCheck();
    	//_CrtSetBreakAlloc(69);//在第一次调用时，注释。调试后输出的{69}后，把数字填入参数内，再次调试，就会在问题出现处中断。    
	    int *a = new int[10];
    }
    ```
    6. 动态链接和静态链接的区别
        - 静态链接库.a在形成可执行文件前，链接器通过符号导出表和重定位的方式，把所需要的外部定义都拉进可执行文件内，形成一个可执行文件。这样做的好处是，运行时，可执行文件都已经完备了，加载比较快。但是由于静态链接会将库都拷贝进可执行文件里。那么有些常用函数会被大量拷贝，非常浪费资源。而且如果库更新了，那么需要重新链接形成可执行文件，很麻烦。
        - 动态链接库.so则是在把文件加载进内存的时候，发现需要一个动态链接库，则临时加载这个动态链接库或者是运行时才调用这个库则运行过程中去加载这个库。这样来说程序的运行加载会变慢，但是该动态库是被所有可执行程序共同加载的，只有一份，很节省空间，且更新起来也不影响其他东西，很方便。  
        - 为什么动态链接库不占空间。这用到了虚拟内存和内存映射的知识。内存映射将物理内存映射为该进程的一个连续的虚拟内存空间。虽然每个虚拟内存空间之间互不干扰。但是每个虚拟内存都存在一些对于进程来说是只读的区域，比如“printf”这个函数区域，那么这样我们可以用共享对象的方式，把同一部分的物理内存多次映射到多个虚拟内存，就实现了动态链接。所以其实在物理内存上，是只有一份的。
    7. 写一个c程序辨别32位还是64位  
        - 目前没试过，但我觉得有两种好用的方法
            1. sizeof(void*)，这种方式，32位系统的地址长度4字节，64位系统8字节。
            2. long int a=0x80000000;如果是32位,则是-1，64位则是正数。
       
    8. 写一个程序判断大端小端
        -   
    9. 进程间通讯机制
        - 匿名管道：  
        - 有名管道：  
        - 消息队列：  
        - 共享内存：  
        - Socket：
        - 信号量：
        - 信号： 
    10. Linux系统文件机制
        - 每个进程有一个描述符表，这个表管理了进程打开的文件描述符。
        - 每个描述符表中打开的描述符都会指向一个打开文件表，这个表是所有进程共享的。这张表里有一个项叫做文件位置，管理了目前“光标”在文件中的位置，根据这个位置，读取或者写入文件。而父子进程共享这个位置，所以父进程读取了，子进程读取的时候会从后面跟着。但是如果是同一进程打开同一文件两次，则是有两张打开文件表，所以是各管各的。
        - 打开文件表指向v-node表，这个表存储了文件的基本信息
          

    11. 进程和线程
        - 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动。进程是系统进行资源分配和调度的一个独立单位。
        - 线程是一个进程的实体，是CPU调度和分派的基本单位。只拥有自己的栈、寄存器和程序计数器。
        
    12. 智能指针    
        - 智能指针表现为一个普通的指针，但是其具有更加优良的 资源创建报错、资源自动释放等功能。更加便于管理资源。
        - 智能指针是一个模板类，他运用了RAII（资源获取即初始化）的技术，使得他表现得像一个指针。
        - C++11拥有三种智能指针：shared_ptr,unique_ptr,weak_ptr.
            - 其中shared_ptr共享指针可以共享一个对象，当多个shared_ptr指向同一个对象时，使用引用计数use_count可以管理资源。当对象第一次被指时，use_count=1，之后每被拷贝给一个shared_ptr，则+1，如果时赋值，则原来的-1，后来的+1.当use_count==0的时候，自动释放所指的资源。shared_ptr有一个要注意的时循环引用。如果我一个shared_ptr指向一个shared_ptr指针p，p指向另一个shared_ptr指针指的shared_ptr指针s，且s指向p。  那么s和p的use_count=2，且出作用域的时候，两者都-1，还是1，不会释放，造成内存泄漏。  
        ```C++  

                shared_ptr<p> a    ------------>   ->|shared_ptr<s>|--
                                                   |       |         |
                                                   |   use_count=2   |
                                                   |                 |
                                                   |                 |
                                                   |                 |
                                                   |   use_count=2   |
                                                   |       |         |
                shared_ptr<s> b    ------------>   --|shared_ptr<p>|<-
        ```
          - 就如上图所示，右边的两个对象分别存的也是shared_ptr指针，且互相指。那么如果超出作用域，左边两个指针a,b都被析构了，那么对于右边两个对象的use_count都会-1，但是可以看到原来右边两个对象的use_count其实是2，所以-1=1，不会被释放，两个内存就僵住了，必须有个人先走，否则两个都不走。  
          - 这时候，就需要weak_ptr的出现了，为了防止这种情况下很难处理内存的释放，那么我们可以把其中一个做成weak_ptr，weak_ptr可以用shared_ptr或者weak_ptr去初始化，但是和shared_ptr不同的是，weak_ptr不会增加use_count。如下图。由于a所指的对象里面放的是weak_ptr，所以b所指的对象的use_count并不是2，还是1（因为weak_ptr指向他并不增加use_count）。那么当a，b超出作用域的时候，分别析构使得两个对象的use_count都-1，此时不会像刚才循环shared_ptr那样两个都是2-1=1了，其中有一个是1-1=0，那么就达到了刚才所说的其中一个先走了，这样僵局就打破了。两个人都顺利的走了。88~
        ```C++
                shared_ptr<p> a    ------------>   ->| weak_ptr<s> |--
                                                   |       |         |
                                                   |   use_count=2   |
                                                   |                 |
                                                   |                 |
                                                   |                 |
                                                   |   use_count=1   |
                                                   |       |         |
                shared_ptr<s> b    ------------>   --|shared_ptr<p>|<-
        ```
           - 那么unique_ptr是干嘛的呢，unique_ptr胆子很小，其实他啥也干不了，他就表现得跟一个指针一样，只能一个指一个，不能和shared_ptr那样多个指一个。（看上去很专一）但是有一个所有权问题。就是一个unique_ptr指向了一个对象后，那么这个unique_ptr没法被赋值，拷贝。只能通过一些move转换所有权，就是把自己指向的对象给别人，那么自己就不指向那个对象了。或者realse释放所有权，我不要了（但是不释放，你们谁要拿走，且自己置空，返回这块内存地址，注意这是这块内存最后的名字了，你没保存你就找不到他了就铁定泄露了）。但是他比普通的强的就是他被析构的时候，还是会去释放自己指向的那块内存的。


13. 隐式转换
    - 就一条规则，小的往大的转，尽可能防止精度丢失。short->int->unsigned int->long->double.
    - =右边转成左边。
    - 函数中实参转成形参。
    - 返回数据类型转成函数返回值类型。
7. linux查看文件夹下子文件内所有文件。（Linux下的常用命令）
   - ls -R

8. HTTPS连接的建立过程。
    ![https](http://ww2.sinaimg.cn/large/005xfSxkly1g17uj08q5cj30mn0iy46r.jpg)
    1. 客户端发起HTTPS请求，并告知服务端自己支持的密钥算法套件，包括加密算法和哈希算法。
    2. 服务端获知客户端的加解密能力后，如果自己支持，则返回自己的证书和公钥，如果不行则连接断开。
    3. 客户端接收到证书后，验证证书的合法性，如果合法，则生成一段随机密码（用于后续的对称密钥），把他和用哈希算法哈希他声称的数字签名通过服务端给的公钥加密一起发过去。
    4. 服务端接收到一段加密内容后，用私钥解密这段内容，然后用解密出来的密码和哈希算法哈希这个密码得到的值与数字签名对照，如果一样，说明中途没有被人修改，则之后就使用这个随机密码作为对称密钥进行通信。  
   
   ***总之，分三大步，第一是证书的验证，第二是用非对称加密来商量对称加密怎么加密，商量完了就是第三步，用对称加密进行通信。***
   - 非对称加密算法：RSA、DSA/DSS
   - 对称加密算法：AES、RC4、3DES
   - hash算法：MD5,SHA1,SHA256

9. 前序遍历
    ```C++
    //递归版本
    void preorder(Tree* root){
        if(root!=NULL){
            do something to root;
            preorder(root->left);
            preorder(root->right);
        }
    }
    //非递归版本
    void preorder2(Tree* root){
        stack<Tree*> s;
        Tree* pnode=root;
        while(pnode||!s.empty()){
            if(pnode){
                do something to pnode;
                s.push(pnode);
                pnode=pnode->left;
            }
            else{
                pnode=s.pop();
                pnode=pnode->right;
            }
        }
    }

    ```
10. 中序遍历
    ```C++
    //递归版本
    void inorder(Tree* root){
        if(root!=NULL){
            inorder(root->left);
            do something to root;
            inorder(root->right);
        }
    }

    //非递归版本
    void inorder(Tree* root){
        stack<Tree*> s;
        Tree* pnode=root;
        while(pnode||!s.empty()){
            if(pnode){
                s.push(pnode);
                pnode=pnode->left;
            }else{
                pnode=s.pop();
                do something to pnode;
                pnode=pnode->right;
            }
        }
    }

11. 后序遍历
    ```C++
    //递归版本
    void reorder(Tree* root){
        if(root!=NULL){
            reorder(root->left);
            reorder(root->right);
            do something to root;
        }
    }

    //非递归版本
    void reorder(Tree* root){
        stack<Tree*> s;
        Tree* prenode;
        prenode=NULL;
        s.push(root);
        Tree* cur;
        while(!s.empty()){
            cur=s.top();
            if((cur->left==NULL&&cur->right==NULL)||(prenode!=NULL&&(prenode==cur->left||prenode==cur->right))){
                cout<<cur->data;
                s.pop();
                prenode=cur;
            }
            else{
                if(cur->right){
                    s.push(cur->right);
                }
                if(cur->left){
                    s.push(cur->left);
                } 

            }
        }
    }

12. 死锁的产生条件的解决措施
    - 四大条件：1.互斥性：每个资源只允许一个进程占有，占有后不能被其他进程获取。  
               2.不可抢占：当资源未被释放时，其他进程不能抢占该资源。
               3.占有且等待：一个进程占有了某资源，但需求另一个资源，另一个资源必须等待其他进程释放。
               4.循环等待：形成一种进程链，使得每个进程都都占有下一个进程所需要的至少一种资源。
    - 解决方案：
    1. 预防死锁：1.破坏“不可抢占”：当一个进程想要获取的资源无法得到满足时，就释放自己拥有的资源，待之后需要时重新申请。2.破坏“占有且等待”：进程开始时就分配所有资源。3.破坏“循环等待”：给资源编号，每个进程占有资源i，那么该进程只能申请比i大的资源，这样就不会循环了。
    2. 避免死锁：只允许不会产生死锁的进程去申请资源。银行家算法。还可以按照一定顺序加锁，给锁加超时时长，
    3. 死锁检测：通过对现有的锁和资源请求进行记录，如果某次请求资源失败时，通过去检查这个记录去判断是否发生了死锁，如果发生了就跳到死锁处理机制去。
    4. 死锁处理：资源剥夺法（挂起某些死锁进程，将资源分配给其他进程，但应防止该挂起进程长期获取不到资源，长期处于饥饿状态。）、进程撤销法（杀死部分或者全部死锁进程）、进程回退法（让部分死锁进程回退到可以避免死锁的地步）

#include<iostream>
#include<string>
#include<queue>
#include<sstream>
using namespace std;

int main() {
	queue<int> q1;
	int level = 0;
	vector<int> input;
	string ss;
	getline(cin, ss);
	int k = 0;
	int m = ss.size();

	if (m>2&&ss[0] == 'N'&&ss[1] == 'o') {
		cout << "True";
		return 0;
	}
	while (k<m) {
		int start = k;
		while (k<m&&ss[k] != ',') {
			k++;
		}
		input.push_back(stoi(ss.substr(start, k - start)));
		k++;
	}
	int i = 0;
	int n = input.size();
	if (n == 0) { cout << "True"; return 0; }
	q1.push(input[i]);
	while (i<n-1) {
		if (input[++i] <= q1.front()) {
			q1.push(input[i]);
		}
		else {
			cout << "False";
			return 0;
		}
		if (input[++i] >= q1.front()) {
			q1.push(input[i]);
		}
		else {
			cout << "False";
			return 0;
		}
		q1.pop();
	}
	cout << "True";
	return 0;
}
13. /r和/r/n的区别
    /r是指回车，/n是指换行。在最开始，/r回车，回车的意义是将光标移到该行最左侧，如果在windows系统下只用/r，则会回到改行最左端，不会进行换行。/n进行换行，但不会回到行的最左边。但是在unix系统中，/n就可以完成windows的/r/n操作。（注：键盘上的回车按键在windows下会有2个输入，就是/r/n，和/r所对应的回车意义不同）  
14. 构造函数可以抛出异常，但是由于构造函数没有返回值，所以需要一个非局部变量取指示是否构造成功，用户需要去检查这个值。或者用户在构造完后去检查这个对象是否正常。析构函数不可以抛出异常，因为其他函数在抛出异常时会调用析构函数。
