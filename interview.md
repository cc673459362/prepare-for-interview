# 后台开发面试问题总结
[简书|后台开发面试问题总结](https://www.jianshu.com/p/7bab37d411a8)

1. 析构函数原理以及步骤  
    - 析构函数的作用：当对象的生命周期结束时，会自动调用析构函数，以清理一些资源，比如释放内存、关闭文件、关闭数据库连接等。
    - 析构函数的顺序：析构函数析构顺序和构造函数构造对象顺序相反，是从派生类开始往基类进去一步步析构。所以，如果在有继承的类对象里，且有虚函数的存在，那么析构函数一定是虚函数。因为如果析构函数不是虚函数，那么基类指针对象调用的析构函数就仅仅是基类析构。而不释放派生类部分的对象，会导致内存泄漏。（因为析构时，编译器已经知道了对象的构造，已经拥有VPTR，所以可以是虚函数。但构造函数明显还不知道，所以不能是虚函数。）  

2. 类对象的内存存储形式  
    - 如果是一个普通的类的对象，那么会在堆（用new）或者栈（函数内创建局部变量）中直接分配类里声明的成员变量空间，并对这些成员变量调用构造进行初始化存储。
    - 成员函数则会有一个ptr指向类代码区，并不会占用堆栈空间。每次a->func()调用成员函数的时候，会根据指针直接去代码区找到函数运行。
    - 如果类拥有虚函数，则对象内存一开始会有一个VPTR，指向该类的虚函数表，实现虚函数的晚捆绑。  
    - 如果该类有多重继承，且上层具有虚继承，则该对象除上面所说以外，还有一个vbptr，该指针指向虚基类表，表中存储了基类成员和自己的偏移量。这种多重继承，只拷贝一份基类成员，但是多一个指针的开销。

3. 进程内存空间分布
    - ![进程内存分布图](http://ww1.sinaimg.cn/large/005xfSxkly1g1031fgnspg30bo09xaac.gif)
    - 内存从上到下分为：内核区、栈（向下增长）、动态库、堆（向上增长）、静态变量以及常量区还有最下面的代码区。
4. 虚函数的作用
    - C++多态通过虚函数实现。可以实现不同对象自动调用不同的接口。在基类中使用virtual关键字使得该函数成为虚函数，且定义和派生类都不需要再次声明virtual关键字。在派生类中重定义虚函数被称为重写（overriding）。
    - 虚函数实现机制是晚捆绑，一般的函数在编译期间就被编译器转化成了CALL 某个地址，然后进入该函数，直到RETURN出来。但是虚函数在编译期间并不知道具体调用什么。只有在运行时，根据该对象的VPTR指向的虚函数表（VTABLE）中寻找真正调用的函数。
    - 所以，虚函数的实现方式是在构造该对象时，在最前面加上一个VPTR，该指针指向一张虚函数表，这张虚函数表里存了该类真正被调用的函数地址。（VPTR是针对对象的，每个对象都有一个，VTABLE是针对类的，不占用对象存储空间。）
    - 当出现多重继承的时候，子类拥有多个VPTR指向多张VTABLE，子类的虚函数跟在第一张VTABLE后面。  
    - 纯虚函数：纯虚函数需要在虚函数声明后面加一个“=0”，拥有纯虚函数的类不允许用户创建对象。纯虚函数不用定义（纯虚析构除外，纯虚析构必须定义函数体，否则析构不做任何操作有违析构本意）。纯虚函数可以让基类成为一个纯粹的接口模板，让子类继承后去实现这个纯虚函数。且限制了该模板基类的对象创建。      
5.  如何定位内存泄漏
    ```C++  
    //在主函数文件中加入如下代码

    #include <stdlib.h>  
    #include <crtdbg.h>  

    /*
    #ifdef _DEBUG  
    #define new new(_NORMAL_BLOCK, __FILE__, __LINE__)  
    #endif  
    */

    void EnableMemLeakCheck()
    {
    	int tmpFlag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
    	tmpFlag |= _CRTDBG_LEAK_CHECK_DF;  
        _CrtSetDbgFlag(tmpFlag);      
    }

    using namespace std;
    int main()
    {
    	EnableMemLeakCheck();
    	//_CrtSetBreakAlloc(69);//在第一次调用时，注释。调试后输出的{69}后，把数字填入参数内，再次调试，就会在问题出现处中断。    
	    int *a = new int[10];
    }
    ```
    6. 动态链接和静态链接的区别
        - 静态链接库.a在形成可执行文件前，链接器通过符号导出表和重定位的方式，把所需要的外部定义都拉进可执行文件内，形成一个可执行文件。这样做的好处是，运行时，可执行文件都已经完备了，加载比较快。但是由于静态链接会将库都拷贝进可执行文件里。那么有些常用函数会被大量拷贝，非常浪费资源。而且如果库更新了，那么需要重新链接形成可执行文件，很麻烦。
        - 动态链接库.so则是在把文件加载进内存的时候，发现需要一个动态链接库，则临时加载这个动态链接库或者是运行时才调用这个库则运行过程中去加载这个库。这样来说程序的运行加载会变慢，但是该动态库是被所有可执行程序共同加载的，只有一份，很节省空间，且更新起来也不影响其他东西，很方便。  
        - 为什么动态链接库不占空间。这用到了虚拟内存和内存映射的知识。内存映射将物理内存映射为该进程的一个连续的虚拟内存空间。虽然每个虚拟内存空间之间互不干扰。但是每个虚拟内存都存在一些对于进程来说是只读的区域，比如“printf”这个函数区域，那么这样我们可以用共享对象的方式，把同一部分的物理内存多次映射到多个虚拟内存，就实现了动态链接。所以其实在物理内存上，是只有一份的。
    7. 写一个c程序辨别32位还是64位  
        - 目前没试过，但我觉得有两种好用的方法
            1. sizeof(void*)，这种方式，32位系统的地址长度4字节，64位系统8字节。
            2. long int a=0x80000000;如果是32位,则是-1，64位则是正数。
       
    8. 写一个程序判断大端小端
        -   
    9. 进程间通讯机制
        - 匿名管道：  
        - 有名管道：  
        - 消息队列：  
        - 共享内存：  
        - Socket：
        - 信号量：
        - 信号： 
    10. Linux系统文件机制
        - 每个进程有一个描述符表，这个表管理了进程打开的文件描述符。
        - 每个描述符表中打开的描述符都会指向一个打开文件表，这个表是所有进程共享的。这张表里有一个项叫做文件位置，管理了目前“光标”在文件中的位置，根据这个位置，读取或者写入文件。而父子进程共享这个位置，所以父进程读取了，子进程读取的时候会从后面跟着。但是如果是同一进程打开同一文件两次，则是有两张打开文件表，所以是各管各的。
        - 打开文件表指向v-node表，这个表存储了文件的基本信息
          

    11. 进程和线程
        - 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动。进程是系统进行资源分配和调度的一个独立单位。
        - 线程是一个进程的实体，是CPU调度和分派的基本单位。只拥有自己的栈、寄存器和程序计数器。
        
