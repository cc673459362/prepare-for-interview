# CMU-RETE算法论文阅读笔记
1. AI领域的发展，导致机器需要学习的规则变得越来越多，导致整个系统的规则匹配速度下降，当规则数量到一定规模，则该专家系统会瘫痪，所以减少规则匹配的时间很重要。
2. （1.1）减少匹配时间的方法主要有两种：
   1. 遗忘模式：专家系统拥有“遗忘”功能，根据一定策略去遗忘系统内的规则，这样会让系统内的规则规模一直保持在可以让系统运行比较高效的状态下。（这种方式是对规则的各类放弃方式的统称，也有一些做法是对进来的规则进行过滤，只对特定的规则加入到专家系统，防止大量规则无限扩大系统规模。）但这种方法有一定的局限性：暂时没看懂，见P16。第二段
   2. 降低单个规则匹配消耗：比如防止形成一些非常“昂贵”的规则。系统在形成规则网络的同时，优化规则网络，降低单个规则的匹配费用。这种方法的局限性很明显，它能减少单条规则的匹配时间，但是随着AI的发展，规则的数量将会迅速增长，这必定不是一个长远的解决方案。
3. （1.2）本篇论文的主要研究点是针对大规模规则下的专家系统运行效率的研究。一般规则数量大于100000条。并且实验使用了大量的学习系统，经研究发现，RETE和TREAT算法的表现最佳，但两者还是随着规则数量增加，效率有线性的降低。这种线性的降低导致了它们对于大规模的学习系统的支持还是有问题。
4. （1.2）本篇论文将RETE算法修改为RETE/UL算法，大幅增强了对于大规模规则系统的支持，比普通算法快2个量级。
5. （1.3）影响学习系统的效率的因素其实不仅仅是规则的规模，还有其他问题：例如一些庞大规则，这样一条非常庞大的单体规则可能也会影响学习系统。但是本论文不讨论这些问题因素。只关注规则数量对专家系统效率的影响。
6. （1.3）本篇论文无法完全解决大规模规则匹配昂贵问题，且这个问题理论上是永远无法彻底解决的。
7. （1.3）本篇论文的方法针对大规模匹配，1000-100000，对于小规模规则10-100数量可能没有效果。
8. （1.3）本篇论文只针对解决大数量的问题，不解决算法本身的匹配效率问题。
9. （1.3）本篇论文假设所有数据可以存在内存中，而不会考虑硬盘问题。有一些研究已经在研究高效的数据库存取方法。
10. （1.3）本篇论文研究的是序列化匹配系统，不考虑并行匹配。虽然并发匹配时解决大规模规则匹配的一个很好的方法，但是在单CPU下序列化匹配的优化对于并行匹配的设计也有很好的指导性。
11. （1.3）本篇论文解决的时全局匹配，而不是部分匹配。有论文提出在匹配的时候去发现在大型规则库内的部分规则去匹配的方法降低匹配消耗。这种方法缺乏在不同情况下的适用性，但也是一个很好的点子。  

## Basic Rete
1. Rete算法包含一个PM（Production Memory）和WM（Working Memory）。WM里存的元素是外部世界的事实（fact）或者是内部处理后的状态（state）。我们将它们称之为WME（Working Memory Element）。
下面的例子就是典型的WMEs：
  ```
  w1:(B1 ^on B2)                 w6:(B2 ^color blue)
  w2:(B1 ^on B3)                 w7:(B3 ^left-of B4)
  w3:(B1 ^color red)             w8:(B3 ^on table)
  w4:(B2 ^on table)              w9:(B3 ^color red)
  w5:(B2 ^left-of B3)
  ```
2. 从上述例子中可以看到，我们的WMEs由一个三元组构成（three-tuples）,用（identifier ^attribute value）的形式来描述。这三个英文名称对于匹配没有特殊的含义。这三者的约束只要是一个常量不是变量就行。
3. PM是产品（rules）的集合。产品通常由一系列的条件，我们称之为LHS，以及一系列的动作，我们称之为RHS组成。Productions通常以下列形式写就：
   ```
   name-of-this-production
   LHS   /*one or more conditions*/
   -->
   RHS   /*one or more actions*/
   ```

4. 匹配算法只针对LHS，它遍历系统去决定哪些规则被完全匹配了。另外的模块负责去执行这些规则的RHS。条件里可以包含变量。下面的例子表示了寻找两个或更多的在红色箱子左边的箱子堆。 
    ```
    find-stack-of-two-blocks-to-the-left-of-a-red-block
     (<x> ^on <y>)
     (<y> ^left-of <z>)
     (<z> *color red)
    -->
    RHS
    ```
5. 匹配算法决定哪些规则可以被当前的WM中的事实所完全匹配。由于我们假定WME由一个三元组构成，所以我们也可以假定每个条件由一个三元组构成。否则两者不可能匹配。
6. Rete算法可以被看成是一个黑盒子，他有两个输入，一个是PM，一个是WM，它只负责将PM中的规则与当前WM中的WME去匹配，如果完全匹配，则交给另外的模块去执行该规则的动作。
   ![RETE黑盒子](http://ww1.sinaimg.cn/large/005xfSxkly1g1yq2rev60j30r10ggq58.jpg)
7. Rete使用数据流网络去代表规则的条件。网络分为两个部分。alpha网络用来测试WME。它将符合条件的WME存储到AM(alpha memories)中。
![RETE网络图](http://ww1.sinaimg.cn/mw690/005xfSxkly1g1yqmo0c6bj30yq0l1aj7.jpg)

  从上图中可以看到。beta网络是由join节点和beta memories构成的。（可能还会有其他一些节点，后面讲。）Join节点的功能是测试两个条件的一致性，也就是说，它的左右输入都是已经符合某个或者某类条件了，那么这个join节点的功能就是将左右已经符合某类条件的事实库再次测试其两边都符合的事实。将它们存到自己的beta memories中。所以beta memories中存储的是符合该规则的部分条件的WMEs，只有走到根节点才是符合该规则所有条件的WMEs。

8. 严格来说，大部分Rete网络的alpha网络不仅仅测试常量比如在单个条件中出现 \<x\> ^ self \<x>.但是这里，论文里很少出现这种条件，且本篇论文的大部分条件都是“相等”判断，连“大于”、“小于”等判断都很少。总之，在基本情况下，alpha网络表现为测试单个WME，而beta啊网络表现为测试两个及两个以上的WMEs。
9. 上述过程也可以用数据库去类比。Working Memory作为关系型数据库的表，而Production则是作为Query。不同的条件匹配就可以看作是对数据库内容的select，将select得到的结果存储与alpha memory中。最终符合规则P的working memory 将会是把前面分别select得到的结果通过join select联合起来。join operation由Beta网络的Join节点完成。每个beta memory里存储了每次join操作得到的结果。每当working memory发生改变，我们便通过alpha网络传送这些改变，并更新alpha memory。这些更新将会被传播到相关的join节点。如果join节点中有实例被改变，那么我们便更新这个beta memory，并将其改变往下传播，知道到达最终的执行节点。
   - 例如，有n个condition c(n)在系统内，那么我们就将他们各自的select结果r(cn)存储在相应的alpha memory中，现在如果规则P由C1...C2...Ck构成。那么如果P被匹配，则过程就是r(c1)Xr(c2)X...xr(ck).其中的X代表着JOIN操作。
10. 能够让RETE算法比普通匹配算法块的原因在于Rete算法可以保存状态。每次改变WM，那么在alpha和beta网络中得到的匹配结果都会保存，那么下次改变WM的时候，就不用所有WMEs都进行重新计算，那么就减少了很多重复计算。（Rete算法的状态保存特性使得它在那种小规模变化的WMEs中表现良好，但并不适用与大规模WMEs的变化。）
11. 第二点则是节点的共享，当production中由一些conditions是相同的，那么这两个production就可以共享这些节点。例如上图中的alpha memoryC3被production P1和P3共享。再例如在beta网络中，如果由一些production的部分condition相同，则可以共用一些beta节点，而不必重新复制一个重复的节点。由于这些节点共享，所以beta网络看上去像是一颗树。
12. Rete模型系统分为四个切入点：add-wme，remove-wme，add-production,remove-production。
13. add-wme。当一个wme被加入到working memory中，那么这个alpha网络将对他进行必要的常量测试然后将他存储与合适的alpha memories中。有几种方法可以去找到合适的alpha memories。
    - Dataflow Network
    - ![dataflow](http://ww1.sinaimg.cn/mw690/005xfSxkly1g25n6mn5jhj30zp0pm0zv.jpg)
    - 如上图，这是一个简单的规则系统网络图，含有C1-C10 10条conditions。对于每个condition，我们做出k个节点做常量测试，用这k个节点作为路径使得WME在路径上进行测试流动。这k个节点的建立过程中，如果本condition的某个节点和另外一个condition的某个节点常量测试一样，则共享该节点。最后在节点末尾增加一个alpha memory。作为wme完成常量测试的输出。
    - 从上图中可以看到，我们只关注了它的constants，而没有关注variable name。因此，C2和C10共享了节点和alpha memory即便他们有不同的variable names。而且condition也有可能不包含任何节点，直接作为top节点的子节点，犹如C9。